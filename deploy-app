#!/usr/bin/env bash
# deploy-app - 🚀 Blazingly Fast Deployment for FonDeDeNaJa Rust OMR 🚀
# Uses current working directory as project directory; builds and brings up docker compose services
# Prioritizes Rust OMR deployment with fallback to legacy Python deployment

set -euo pipefail

PROJECT_DIR="$(pwd)"
COMPOSE_CMD="docker compose"
LOG_FILE="/var/log/deploy-app.log"
DATE_NOW() { date '+%Y-%m-%d %H:%M:%S'; }

log() {
  echo "[$(DATE_NOW)] 🚀 $1" | tee -a "$LOG_FILE"
}

main() {
  log "Deploying blazingly fast Rust OMR in: $PROJECT_DIR"

  # Check for Rust Docker configuration (preferred)
  if [[ -f "$PROJECT_DIR/docker-compose.rust.yml" ]]; then
    log "🚀 Found Rust OMR configuration - deploying blazingly fast version!"
    COMPOSE_FILE="docker-compose.rust.yml"
    
    # Check for Rust Dockerfile
    if [[ ! -f "$PROJECT_DIR/Dockerfile.rust" ]]; then
      log "❌ Dockerfile.rust not found - required for Rust deployment"
      exit 1
    fi
    
  # Fallback to legacy Python configuration
  elif [[ -f "$PROJECT_DIR/docker-compose.yml" ]]; then
    log "⚠️  Using legacy Python configuration (consider upgrading to Rust!)"
    COMPOSE_FILE="docker-compose.yml"
    
    if [[ ! -f "$PROJECT_DIR/Dockerfile" ]]; then
      log "❌ Dockerfile not found in $PROJECT_DIR"
      exit 1
    fi
    
  else
    log "❌ No docker-compose configuration found in $PROJECT_DIR"
    exit 1
  fi

  log "📦 Pulling and rebuilding Docker images for $COMPOSE_FILE..."
  # allow pull to fail gracefully
  $COMPOSE_CMD -f "$COMPOSE_FILE" pull || true
  $COMPOSE_CMD -f "$COMPOSE_FILE" build --no-cache

  log "📡 Bringing up the blazingly fast application..."
  $COMPOSE_CMD -f "$COMPOSE_FILE" up -d

  # Health check for Rust deployment
  if [[ "$COMPOSE_FILE" == "docker-compose.rust.yml" ]]; then
    log "⏳ Waiting for Rust OMR service to be healthy..."
    for i in {1..30}; do
      if curl -f http://localhost:3000/api/health &>/dev/null; then
        log "🚀 Blazingly fast Rust OMR service is healthy!"
        break
      fi
      log "Waiting for health check... ($i/30)"
      sleep 10
    done
  fi

  log "✅ 🚀 Blazingly fast deployment completed successfully! 🚀"

  # Prune step: only when scripts/prune_images.sh exists
  PRUNE_SCRIPT="$PROJECT_DIR/scripts/prune_images.sh"
  if [[ -f "$PRUNE_SCRIPT" ]]; then
    # detect interactive TTY
    if [ -t 0 ]; then
      read -p "Would you like to prune old Docker images for ghcr.io/zipherfox/FonDeDeNaJa? [Y/N]: " prune_ans || prune_ans=N
      if [[ "$prune_ans" =~ ^[Yy] ]]; then
        read -p "How many newest images should be kept? [2]: " keep_ans || keep_ans=2
        if [ -z "$keep_ans" ]; then
          keep_ans=2
        fi
        read -p "Perform actual deletion now? (default: dry-run) [y/N]: " perform_ans || perform_ans=N
        if [[ "$perform_ans" =~ ^[Yy] ]]; then
          log "Running prune (will delete older images)..."
          bash "$PRUNE_SCRIPT" --keep "$keep_ans" --no-dry-run || log "Prune script exited with errors or some images could not be removed"
        else
          log "Running prune in dry-run mode (no images will be deleted)..."
          bash "$PRUNE_SCRIPT" --keep "$keep_ans" || log "Prune script (dry-run) exited with errors"
        fi
      else
        log "Skipping image prune as requested by user"
      fi
    else
      log "Non-interactive session; skipping prune step"
    fi
  else
    log "Prune script not found at $PRUNE_SCRIPT; skipping prune step"
  fi
}

main "$@"
